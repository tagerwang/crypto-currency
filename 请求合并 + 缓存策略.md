# è¿™æ˜¯claude 4.5 aiæä¾›çš„æ–¹æ¡ˆï¼Œå·²ä¿®å¤å¹¶å‘é—®é¢˜

è®©æˆ‘ä¿®æ­£è¿™ä¸ªå¹¶å‘ç«æ€é—®é¢˜ï¼š

## âœ… æ­£ç¡®çš„è¯·æ±‚åˆå¹¶å®ç°

```javascript
class BinanceAPIPool {
  constructor() {
    this.cache = new Map();
    this.pendingRequests = new Map();  // å­˜å‚¨è¿›è¡Œä¸­çš„Promise
    this.weightUsed = 0;
    this.windowStart = Date.now();
    this.maxWeight = 1200;
  }

  async fetchWithDedup(endpoint, params) {
    const cacheKey = `${endpoint}:${JSON.stringify(params)}`;
    
    // 1. æ£€æŸ¥ç¼“å­˜
    const cached = this.cache.get(cacheKey);
    if (cached && Date.now() - cached.timestamp < this.getCacheTTL(endpoint)) {
      console.log(`[Cache Hit] ${cacheKey}`);
      return cached.data;
    }

    // 2. æ£€æŸ¥æ˜¯å¦æœ‰æ­£åœ¨è¿›è¡Œçš„è¯·æ±‚ï¼ˆå…³é”®ï¼šç›´æ¥è¿”å›åŒä¸€ä¸ªPromiseï¼‰
    if (this.pendingRequests.has(cacheKey)) {
      console.log(`[Request Dedup] ${cacheKey} - waiting for existing request`);
      return this.pendingRequests.get(cacheKey);
    }

    // 3. åˆ›å»ºæ–°çš„è¯·æ±‚Promise
    const requestPromise = this.executeWithRateLimit(endpoint, params)
      .then(result => {
        // æˆåŠŸåç¼“å­˜ç»“æœ
        this.cache.set(cacheKey, { 
          data: result, 
          timestamp: Date.now() 
        });
        console.log(`[Request Success] ${cacheKey}`);
        return result;
      })
      .catch(error => {
        // å¤±è´¥ä¹Ÿè¦æ¸…ç†ï¼Œé¿å…æ°¸ä¹…é˜»å¡
        console.error(`[Request Failed] ${cacheKey}`, error);
        throw error;
      })
      .finally(() => {
        // è¯·æ±‚å®Œæˆåæ‰åˆ é™¤ï¼ˆæ— è®ºæˆåŠŸæˆ–å¤±è´¥ï¼‰
        this.pendingRequests.delete(cacheKey);
      });

    // 4. ç«‹å³å­˜å‚¨Promiseï¼ˆåœ¨awaitä¹‹å‰ï¼ï¼‰
    this.pendingRequests.set(cacheKey, requestPromise);
    
    // 5. è¿”å›Promiseï¼ˆå¤šä¸ªç”¨æˆ·ä¼šå…±äº«åŒä¸€ä¸ªPromiseï¼‰
    return requestPromise;
  }

  async executeWithRateLimit(endpoint, params) {
    const weight = this.getEndpointWeight(endpoint);
    
    // é™é¢‘æ§åˆ¶
    const now = Date.now();
    const elapsed = now - this.windowStart;
    
    if (elapsed >= 60000) {
      // é‡ç½®çª—å£
      this.weightUsed = 0;
      this.windowStart = now;
    } else if (this.weightUsed + weight > this.maxWeight) {
      // éœ€è¦ç­‰å¾…åˆ°ä¸‹ä¸€ä¸ªçª—å£
      const waitTime = 60000 - elapsed;
      console.log(`[Rate Limit] Waiting ${waitTime}ms`);
      await this.sleep(waitTime);
      this.weightUsed = 0;
      this.windowStart = Date.now();
    }

    this.weightUsed += weight;
    console.log(`[Weight] Used ${this.weightUsed}/${this.maxWeight}`);
    
    return this.actualRequest(endpoint, params);
  }

  async actualRequest(endpoint, params) {
    const url = new URL(`https://fapi.binance.com${endpoint}`);
    Object.entries(params).forEach(([key, value]) => {
      url.searchParams.append(key, value);
    });

    const response = await fetch(url.toString());
    
    if (!response.ok) {
      throw new Error(`Binance API Error: ${response.status} ${response.statusText}`);
    }

    return response.json();
  }

  getCacheTTL(endpoint) {
    const ttlMap = {
      '/fapi/v1/ticker/24hr': 1000,              // 1ç§’
      '/futures/data/openInterestHist': 60000,   // 1åˆ†é’Ÿ
      '/fapi/v1/klines': 5000,                   // 5ç§’
      '/fapi/v1/depth': 500,                     // 500ms
    };
    return ttlMap[endpoint] || 1000;
  }

  getEndpointWeight(endpoint) {
    const weightMap = {
      '/fapi/v1/ticker/24hr': 1,
      '/futures/data/openInterestHist': 1,
      '/fapi/v1/klines': 1,
      '/fapi/v1/depth': 5,
    };
    return weightMap[endpoint] || 1;
  }

  sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}
```

## ğŸ§ª æµ‹è¯•å¹¶å‘è¯·æ±‚åˆå¹¶

```javascript
// æµ‹è¯•ä»£ç 
const apiPool = new BinanceAPIPool();

async function testConcurrency() {
  console.log('=== Testing 100 concurrent requests ===');
  
  const startTime = Date.now();
  
  // 100ä¸ªç”¨æˆ·åŒæ—¶è¯·æ±‚ç›¸åŒæ•°æ®
  const promises = Array.from({ length: 100 }, (_, i) => {
    return apiPool.fetchWithDedup('/fapi/v1/ticker/24hr', { 
      symbol: 'BTCUSDT' 
    }).then(result => {
      console.log(`User ${i} got result: ${result.lastPrice}`);
      return result;
    });
  });

  const results = await Promise.all(promises);
  
  const endTime = Date.now();
  
  console.log('\n=== Results ===');
  console.log(`Total requests: ${promises.length}`);
  console.log(`Time taken: ${endTime - startTime}ms`);
  console.log(`All results identical: ${results.every(r => r === results[0])}`);
}

// æµ‹è¯•è¿ç»­è¯·æ±‚
async function testSequential() {
  console.log('\n=== Testing sequential requests with cache ===');
  
  // ç¬¬ä¸€æ¬¡è¯·æ±‚
  const result1 = await apiPool.fetchWithDedup('/fapi/v1/ticker/24hr', { 
    symbol: 'BTCUSDT' 
  });
  console.log('Request 1 done');

  // ç«‹å³ç¬¬äºŒæ¬¡è¯·æ±‚ï¼ˆåº”è¯¥å‘½ä¸­ç¼“å­˜ï¼‰
  const result2 = await apiPool.fetchWithDedup('/fapi/v1/ticker/24hr', { 
    symbol: 'BTCUSDT' 
  });
  console.log('Request 2 done (should be cached)');

  // ç­‰å¾…ç¼“å­˜è¿‡æœŸ
  await new Promise(resolve => setTimeout(resolve, 1100));

  // ç¬¬ä¸‰æ¬¡è¯·æ±‚ï¼ˆç¼“å­˜å·²è¿‡æœŸï¼‰
  const result3 = await apiPool.fetchWithDedup('/fapi/v1/ticker/24hr', { 
    symbol: 'BTCUSDT' 
  });
  console.log('Request 3 done (cache expired)');
}

// è¿è¡Œæµ‹è¯•
(async () => {
  await testConcurrency();
  await testSequential();
})();
```

## ğŸ“Š é¢„æœŸè¾“å‡º

```
=== Testing 100 concurrent requests ===
[Request Success] /fapi/v1/ticker/24hr:{"symbol":"BTCUSDT"}
[Request Dedup] /fapi/v1/ticker/24hr:{"symbol":"BTCUSDT"} - waiting for existing request
[Request Dedup] /fapi/v1/ticker/24hr:{"symbol":"BTCUSDT"} - waiting for existing request
... (98 more dedup logs)
[Weight] Used 1/1200
User 0 got result: 95432.50
User 1 got result: 95432.50
... (98 more users)

=== Results ===
Total requests: 100
Time taken: 156ms
All results identical: true  â† æ‰€æœ‰ç”¨æˆ·æ‹¿åˆ°åŒä¸€ä¸ªç»“æœå¯¹è±¡ï¼

=== Testing sequential requests with cache ===
[Request Success] /fapi/v1/ticker/24hr:{"symbol":"BTCUSDT"}
Request 1 done
[Cache Hit] /fapi/v1/ticker/24hr:{"symbol":"BTCUSDT"}
Request 2 done (should be cached)
[Request Success] /fapi/v1/ticker/24hr:{"symbol":"BTCUSDT"}
Request 3 done (cache expired)
```

## ğŸ”‘ å…³é”®æ”¹è¿›ç‚¹

1. **Promiseå­˜å‚¨æ—¶æœº**ï¼šåœ¨ `await` **ä¹‹å‰**å°±å­˜å…¥ `pendingRequests`
2. **Promiseå…±äº«**ï¼šå¤šä¸ªå¹¶å‘è¯·æ±‚è¿”å›**åŒä¸€ä¸ªPromiseå¯¹è±¡**
3. **æ¸…ç†æ—¶æœº**ï¼šåœ¨ `finally` ä¸­æ¸…ç†ï¼Œç¡®ä¿æˆåŠŸå’Œå¤±è´¥éƒ½ä¼šæ¸…ç†
4. **é”™è¯¯å¤„ç†**ï¼šå¤±è´¥çš„è¯·æ±‚ä¹Ÿè¦ä» `pendingRequests` ä¸­åˆ é™¤ï¼Œé¿å…æ°¸ä¹…é˜»å¡

## ğŸš€ è¿›é˜¶ä¼˜åŒ–ï¼šæ”¯æŒä¸åŒå‚æ•°çš„æ‰¹é‡è¯·æ±‚

```javascript
class AdvancedBinanceAPIPool extends BinanceAPIPool {
  async fetchMultiple(requests) {
    // requests: [{ endpoint, params }, ...]
    
    const promises = requests.map(({ endpoint, params }) => 
      this.fetchWithDedup(endpoint, params)
    );

    return Promise.all(promises);
  }

  // æ‰¹é‡è·å–å¤šä¸ªsymbolçš„ticker
  async getMultipleTickers(symbols) {
    return this.fetchMultiple(
      symbols.map(symbol => ({
        endpoint: '/fapi/v1/ticker/24hr',
        params: { symbol }
      }))
    );
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const pool = new AdvancedBinanceAPIPool();

// 100ä¸ªç”¨æˆ·è¯·æ±‚ä¸åŒçš„äº¤æ˜“å¯¹
const results = await pool.getMultipleTickers([
  'BTCUSDT', 'ETHUSDT', 'BNBUSDT'
]);
```

ç°åœ¨è¿™ä¸ªå®ç°åº”è¯¥èƒ½å®Œç¾å¤„ç†å¹¶å‘è¯·æ±‚äº†ï¼æ¯ä¸ªå”¯ä¸€çš„è¯·æ±‚ï¼ˆendpoint + paramsç»„åˆï¼‰åªä¼šè§¦å‘ä¸€æ¬¡å®é™…çš„APIè°ƒç”¨ï¼Œæ‰€æœ‰ç­‰å¾…è¯¥è¯·æ±‚çš„ç”¨æˆ·ä¼šå…±äº«åŒä¸€ä¸ªPromiseçš„ç»“æœã€‚ ğŸ‰